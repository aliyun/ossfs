diff --git a/ecosystem/oss.cpp b/ecosystem/oss_patched.cpp
similarity index 98%
rename from ecosystem/oss.cpp
rename to ecosystem/oss_patched.cpp
index 74a87db..4200895 100644
--- a/ecosystem/oss.cpp
+++ b/ecosystem/oss_patched.cpp
@@ -14,7 +14,7 @@ See the License for the specific language governing permissions and
 limitations under the License.
 */

-#include "oss.h"
+#include "oss_patched.h"

 #include <netinet/in.h>
 #include <photon/common/alog-stdstring.h>
@@ -34,8 +34,11 @@ limitations under the License.
 #include <string>
 #include <unordered_map>

+#include "common/fault_injector.h"
+#include "common/logger.h"
+
 namespace photon {
-namespace objstore {
+namespace objstore_from_photon {

 // unused constants will trigger compile error in photon,
 // unless they are defined in a header file
@@ -162,6 +165,9 @@ class OssUrl {
 static int do_http_call(HTTP_STACK_OP& op, const ClientOptions& options,
                         std::string_view object, std::string* code = nullptr) {
   int ret = -1;
+  if (IS_FAULT_INJECTION_ENABLED(FI_OssError_Call_Timeout)) {
+    LOG_ERROR_RETURN(ETIMEDOUT, ret, "mock oss request timeout");
+  }
   auto retry_times = options.retry_times;
   auto retry_interval = options.retry_base_interval_us;

@@ -173,6 +179,11 @@ __retry:
   int __saved_errno = errno;
   {
     int r = 0;
+    FAULT_INJECTION(FI_OssError_Failed_Without_Call, [&]() {
+      r = -1;
+      op.status_code = -1;
+      __saved_errno = EIO;
+    });
     auto start_time = std::chrono::steady_clock::now();
     LOG_DEBUG("Sending oss request ` ` Range[`]", verbstr[op.req.verb()],
               op.req.target(), op.req.headers["Range"]);
@@ -187,6 +198,11 @@ __retry:
         "Got oss response ` ` Range[`], code=` content_length=` latency_us=`",
         verbstr[op.req.verb()], op.req.target(), op.req.headers["Range"],
         op.resp.status_code(), op.resp.headers.content_length(), latency);
+    FAULT_INJECTION(FI_OssError_Call_Failed, [&]() {
+      r = -1;
+      op.status_code = -1;
+      __saved_errno = EIO;
+    });
     if (r < 0) {
       if (retry_times-- > 0) {
         photon::thread_usleep(retry_interval);
@@ -196,6 +212,11 @@ __retry:
         goto __retry;
       }
     }
+    FAULT_INJECTION(FI_OssError_5xx, [&]() {
+      r = -1;
+      op.status_code = 503;
+      __saved_errno = EIO;
+    });
   }

   if (op.status_code != 200 && op.status_code != 206 && op.status_code != 204) {
@@ -216,6 +237,9 @@ __retry:
           error_res["EC"].to_string_view());
       // clang-format on

+      FAULT_INJECTION(FI_OssError_Qps_Limited,
+                      [&]() { code_view = "TotalQpsLimitExceeded"; });
+
       if (code_view.find("QpsLimitExceeded") != std::string::npos) {
         if (qps_limit_retry_interval > 0) {
           photon::thread_usleep(qps_limit_retry_interval);
@@ -679,6 +703,8 @@ retry:
     if (key) deleted_size++;
   }

+  FAULT_INJECTION(FI_Oss_Partial_Deletion,
+                  [&]() { deleted_size--; });
   if (deleted_size != to_delete_size) {
     // Partial deletion happens when OSS server side is with pressure.
     // If this is the case , we just have another try. It's OK if some keys
@@ -856,6 +882,7 @@ retry:
   uint64_t content_length = op.resp.headers.content_length();
   auto ret = op.resp.readv(iov, iovcnt);

+  FAULT_INJECTION(FI_OssError_Read_Partial, [&]() { ret--; });
   // we have encountered partial read issue because of the socket was
   // unexpectedly closed
   if (ret != static_cast<ssize_t>(content_length)) {
diff --git a/ecosystem/oss.h b/ecosystem/oss_patched.h
similarity index 99%
rename from ecosystem/oss.h
rename to ecosystem/oss_patched.h
index c7eefba..1e151b1 100644
--- a/ecosystem/oss.h
+++ b/ecosystem/oss_patched.h
@@ -28,7 +28,7 @@ limitations under the License.
 #include <vector>

 namespace photon {
-namespace objstore {
+namespace objstore_from_photon {

 using StringKV = ordered_string_kv;
